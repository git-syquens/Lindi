# Session 2025-12-24: MPU6050 Sensor Integratie & Flickering Issues

## Doel van de sessie
Integratie van MPU6050 accelerometer data met Level menu UI (Pitch/Roll bars).

## Wat is bereikt
1. **MPU6050 sensor data flow geïmplementeerd**:
   - `mpu6050_read_task()` berekent pitch/roll uit accelerometer via `atan2()`
   - Globale variabelen `current_pitch`, `current_roll` met mutex synchronisatie
   - `level_menu_update_task()` leest data en update bars

2. **Logaritmische mapping geïmplementeerd**:
   - 75% van bar range voor ±10° (meest voorkomende hoeken)
   - 25% voor 10-30° (extreme kanteling)
   - Functie: `map_angle_to_bar()`

3. **Change detection toegevoegd** om onnodige redraws te voorkomen:
   - `prev_pitch_mapped` en `prev_roll_mapped` tracken vorige waarden
   - Bars en labels worden alleen bijgewerkt als waarde verandert

## Kritieke bevindingen: I2C Frequentie

| Frequentie | Resultaat |
|------------|-----------|
| **10kHz** | ✅ Sensor werkt, maar traag (14 bytes = ~14ms) |
| **50kHz** | ❌ ESP_FAIL - MPU6050 niet gevonden |
| **100kHz** | ❌ ESP_FAIL - MPU6050 niet gevonden |

**Conclusie**: De MPU6050 clone vereist 10kHz I2C. Dit is 10x langzamer dan standaard en kan bijdragen aan timing issues.

## Flickering probleem - Root Cause Analyse

### Wat we hebben geprobeerd:
1. Change detection (alleen update bij waarde verandering) → Niet voldoende
2. Lagere update rate (100ms / 10Hz) → Niet voldoende
3. I2C frequentie verhogen → Sensor werkt dan niet

### Mogelijke oorzaken (nog te onderzoeken):
1. **LVGL invalidation**: Elke `lv_bar_set_value()` en `lv_bar_set_start_value()` triggert `lv_obj_invalidate()`, zelfs binnen dezelfde update cycle
2. **Double buffer niet effectief**: Display buffer flush timing
3. **I2C blocking**: 10kHz is traag, kan 14ms blokkeren per read
4. **FreeRTOS task scheduling**: MPU task en GUI task kunnen conflicteren

### Potentiële oplossingen voor morgen:
1. **Batch LVGL updates**: Alleen 1x per frame updaten, niet 4x (2 bars × 2 calls)
2. **Custom bar widget**: Eigen widget maken die start_value en value in 1 operatie zet
3. **DMA voor I2C**: Async I2C reads om blocking te vermijden
4. **Dirty flag patroon**: Update alleen in `lv_task_handler()` callback, niet vanuit LVGL task

## Huidige code state

### Relevante wijzigingen in main.c:
```c
// I2C op 10kHz (vereist voor clone MPU6050)
#define I2C_MASTER_FREQ_HZ   10000

// Globale variabelen voor sensor data
static float current_pitch = 0.0f;
static float current_roll = 0.0f;
static SemaphoreHandle_t mpu_mutex = NULL;

// Previous values voor change detection
static int16_t prev_pitch_mapped = 0;
static int16_t prev_roll_mapped = 0;

// Update rates
- MPU read task: 100ms (10Hz)
- LVGL level update task: 100ms (10Hz)
```

### Belangrijke functies:
- `map_angle_to_bar()` - Logaritmische mapping
- `level_menu_update_task()` - UI update met change detection
- `mpu6050_read_task()` - Sensor readout

## Volgende stappen
1. Onderzoek LVGL bar widget internals - hoe minimaliseer je invalidations
2. Test: Update bars alleen als Level tab actief is
3. Test: Verlaag update rate naar 200ms (5Hz) - is dat acceptabel voor UX?
4. Overweeg: Gebruik `lv_obj_invalidate()` handmatig na alle updates ipv per call

## Git status
Uncommitted changes - commit voor morgen met message:
"WIP: MPU6050 sensor integration with flickering issues"
